<!doctype html><html lang=en-ca>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=generator content="Hugo 0.91.2">
<title>Tutorial: Optimising R code - Blog—Max Turgeon</title>
<meta property="og:title" content="Tutorial: Optimising R code - Blog—Max Turgeon">
<link href=https://maxturgeon.ca/blog/icon.png rel=icon type=image/x-icon>
<link href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css rel=stylesheet type=text/css>
<link rel=stylesheet href=/blog/css/fonts.css media=all>
<link rel=stylesheet href=/blog/css/main.css media=all>
</head>
<body>
<div class=wrapper>
<header class=header>
<nav class=nav>
<a href=/blog/ class=nav-logo>
<img src=/blog/avatar.jpeg width=50 height=50 alt="Max Turgeon">
</a>
<ul class=nav-links>
<li><a href=https://maxturgeon.ca/>Home</a></li>
</ul>
</nav>
</header>
<main class=content role=main>
<article class=article>
<span class=article-duration>20 min read</span>
<h1 class=article-title>Tutorial: Optimising R code</h1>
<span class=article-date>2015-09-10</span>
<div class=article-content>
<p>The R language is very good for statistical computations, due to its strong functional capabilities, its open source philosophy, and its extended package ecosystem. However, it can also be quite slow, because of some <a href=http://adv-r.had.co.nz/Performance.html#language-performance>design choices</a> (e.g. lazy evaluation and extreme dynamic typing).</p>
<p>This tutorial is mainly based on Hadley Wickam&rsquo;s book <a href=http://adv-r.had.co.nz/>Advanced R</a>.</p>
<h3 id=before-optimising>Before optimising&mldr;</h3>
<p>First of all, before we start optimising our R code, we need to ask ourselves a few questions:</p>
<ol>
<li>
<p>Is my code doing what I want it to do?</p>
</li>
<li>
<p>Do I really need to make my code faster?</p>
</li>
<li>
<p>Is considerable speed up even possible?</p>
</li>
</ol>
<p>For the first point, is to useful to keep the following quote in mind:</p>
<blockquote>
<p>Premature optimisation is the root of all evil. (Donald Knuth)</p>
</blockquote>
<p>When writing code, we have a specific task in mind, and this has to be our main focus. To make our lives simpler, it is important to write simple, understandable code to start with; it is considerably easier to debug simple code than complex code. Only when we are certain that our code is correct can we turn to the next point.</p>
<p>An R script that will be used only once does not necessarily need to be optimised, and writing your code quickly will probably be more important than writing code that <em>runs</em> quickly.</p>
<p>Finally, when your code is bug-free and you do need to make it faster, you need to identify the bottle-necks, the places where your code spends the most time, and you need a way to compare the speed of multiple expressions. These two things are known as <em>profiling</em> and <em>benchmarking</em>; we will treat them both in what follows.</p>
<h3 id=benchmarking>Benchmarking</h3>
<p>There are a few ways to time your code. The simplest is to use the function <code>system.time()</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>system.time</span>(x <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>runif</span>(<span style=color:#ae81ff>10</span>^6))
</code></pre></div><pre tabindex=0><code>## utilisateur     système      écoulé 
##        0.10        0.01        0.11
</code></pre><p>However, this timing will depend on your OS, it will generally differ from one run to the other, and therefore it is not clear how to use it to compare two or more expressions. Nonetheless, it is probably the way to go when you want to time expressions that take a long time to run.</p>
<p>For comparisons, we will use the <code>microbenchmark</code> package. Its <code>microbenchmark</code> function will run a series of expressions multiple times and return a distribution of running times. It can also be used with <code>ggplot2</code> to output a nice graphical display of the comparisons.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>library</span>(microbenchmark); <span style=color:#a6e22e>library</span>(ggplot2)
<span style=color:#75715e># Create a dataframe with random values</span>
data <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>data.frame</span>(<span style=color:#e6db74>&#34;column1&#34;</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>runif</span>(<span style=color:#ae81ff>1000</span>), 
                   <span style=color:#e6db74>&#34;column2&#34;</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rnorm</span>(<span style=color:#ae81ff>1000</span>))

<span style=color:#75715e># Extract the first entry of the 666th row</span>
compare <span style=color:#f92672>&lt;-</span> microbenchmark<span style=color:#f92672>::</span><span style=color:#a6e22e>microbenchmark</span>( <span style=color:#e6db74>&#34;extract1&#34;</span> <span style=color:#f92672>=</span> {
  data[666, <span style=color:#ae81ff>1</span>]
}, <span style=color:#e6db74>&#34;extract2&#34;</span> <span style=color:#f92672>=</span> {
  data[[1]][666]
})

compare
</code></pre></div><pre tabindex=0><code>## Unit: microseconds
##      expr    min      lq     mean  median      uq    max neval
##  extract1 22.021 22.9945 24.74206 23.2465 23.7395 98.219   100
##  extract2 10.384 11.3535 13.13219 12.3750 12.8605 57.486   100
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>ggplot2<span style=color:#f92672>::</span><span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=unnamed-chunk-4-1.png alt="plot of chunk unnamed-chunk-4"></p>
<p>So we compared two ways of extracting an element in the data frame: first, we think of <code>data</code> as being matrix-like and extract based on its row and column position; or we remember that data frames are actually <em>lists</em> and extract the element by using the list methods. As we can see, the latter is about twice faster than the former. However, by looking at the units (i.e. microseconds), we see that the difference is quite minimal and unlikely to improve your code (unless you perform this operation millions of times).</p>
<p>The <code>microbenchmark</code> function is the main tool we will use below to benchmark snippets of code and, most importantly, compare different implementations of a same idea.</p>
<h3 id=before-going-into-profiling>Before going into profiling&mldr;</h3>
<p>As I mentionned above, R has the reputation of being slow. However, we have to keep in mind that most of the time, slow R code can be made faster by simply coding in a way that is more natural for R. And to understand what is natural, we need to understand a bit more about how R works.</p>
<h4 id=r-is-an-interpreted-language>R is an interpreted language</h4>
<p>This means that the R interpreter translates our script into small chunks of pre-compiled code. The <a href=https://www.r-project.org/>most common implementation of R</a> is coded using about 50% of C code and 25% of FORTRAN code.</p>
<p>Vectorization is a way of coding in R which tries to make the best use of the pre-compiled code. The main idea is to code in such a way that our computations are done on <em>vectors</em> instead of <em>numbers</em>. We will look at two examples.</p>
<p>First, let&rsquo;s say we want to compute the sum of all pairs of positive integers from 1 to 100. We could do this using a double loop, or in a <em>vectorized</em> way, using the <code>outer</code> function:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>numbers <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>100</span>

compare <span style=color:#f92672>&lt;-</span> microbenchmark<span style=color:#f92672>::</span><span style=color:#a6e22e>microbenchmark</span>(<span style=color:#e6db74>&#34;2loops&#34;</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>for</span>(i in numbers) {
    <span style=color:#a6e22e>for</span>(j in numbers) {
      i <span style=color:#f92672>+</span> j
    }
  }
}, <span style=color:#e6db74>&#34;vect&#34;</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>outer</span>(numbers, numbers, `+`)
})

compare
</code></pre></div><pre tabindex=0><code>## Unit: microseconds
##    expr      min        lq       mean    median        uq      max
##  2loops 3030.975 3093.1255 3324.46216 3159.6165 3231.6265 5304.771
##    vect   79.854   82.4825   95.66377   92.1305  104.1775  162.883
##  neval
##    100
##    100
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>ggplot2<span style=color:#f92672>::</span><span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=unnamed-chunk-5-1.png alt="plot of chunk unnamed-chunk-5"></p>
<p>There is a 40-fold difference between the two expressions!</p>
<p>As a second example, let&rsquo;s compute the mean across all rows of a matrix. We will do it using three different approaches: a for loop, using the <code>apply</code> function, and using the <code>rowMeans</code> function:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>mat <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>matrix</span>(<span style=color:#a6e22e>rnorm</span>(<span style=color:#ae81ff>20</span><span style=color:#f92672>*</span><span style=color:#ae81ff>100</span>), nrow<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>, ncol<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>)

compare <span style=color:#f92672>&lt;-</span> microbenchmark<span style=color:#f92672>::</span><span style=color:#a6e22e>microbenchmark</span>(<span style=color:#e6db74>&#34;loop&#34;</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>for</span>(i in <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#a6e22e>nrow</span>(mat)) {
    <span style=color:#a6e22e>mean</span>(mat[i,])
  }
}, <span style=color:#e6db74>&#34;apply&#34;</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>apply</span>(mat, <span style=color:#ae81ff>1</span>, mean)
}, <span style=color:#e6db74>&#34;rowMeans&#34;</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>rowMeans</span>(mat)
})

compare
</code></pre></div><pre tabindex=0><code>## Unit: microseconds
##      expr     min       lq      mean  median       uq      max neval
##      loop 746.423 766.4940 851.05493 788.150 864.4910 3047.323   100
##     apply 863.475 883.7845 923.21638 899.168 945.9720 1084.456   100
##  rowMeans  18.150  19.2530  22.51806  22.703  24.4285   34.650   100
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>ggplot2<span style=color:#f92672>::</span><span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=unnamed-chunk-6-1.png alt="plot of chunk unnamed-chunk-6"></p>
<p>Again, we see close to a 40-fold difference.</p>
<p>What vectorization does is essentially moving the for loop from R to C. Moreover, the function <code>apply</code> is simply a wrapper for a loop, and this is why it is usually as fast as a loop (in this example, it is actually <em>slower</em> than a loop, because we are not recording the results of the loop but apply is).</p>
<p>Let&rsquo;s look at another example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#75715e># Create a vector of values</span>
categories <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>(<span style=color:#e6db74>&#34;Low&#34;</span>, <span style=color:#e6db74>&#34;Middle&#34;</span>, <span style=color:#e6db74>&#34;High&#34;</span>)

values <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>sample</span>(categories, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>, replace <span style=color:#f92672>=</span> <span style=color:#66d9ef>TRUE</span>)

<span style=color:#75715e># Change the vector of values to numeric</span>
<span style=color:#75715e># 1. Using a loop</span>
values_num1 <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>rep_len</span>(<span style=color:#66d9ef>NA</span>, <span style=color:#a6e22e>length</span>(values))
<span style=color:#a6e22e>for </span>(i in <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#a6e22e>length</span>(values_num1)) {
  <span style=color:#a6e22e>if </span>(values[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Low&#34;</span>) values_num1[i] <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>0</span>
  <span style=color:#a6e22e>if </span>(values[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Middle&#34;</span>) values_num1[i] <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span>
  <span style=color:#a6e22e>if </span>(values[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;High&#34;</span>) values_num1[i] <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>2</span>
}

<span style=color:#75715e># 2. Using vectorization</span>
values_num2 <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>as.numeric</span>(values <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Middle&#34;</span>) <span style=color:#f92672>+</span> 
  <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>as.numeric</span>(values <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;High&#34;</span>)

<span style=color:#a6e22e>identical</span>(values_num1, values_num2)
</code></pre></div><pre tabindex=0><code>## [1] TRUE
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#75715e># Compare the two implementations</span>
<span style=color:#a6e22e>library</span>(ggplot2); <span style=color:#a6e22e>library</span>(microbenchmark)

compare <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>microbenchmark</span>(<span style=color:#e6db74>&#34;loop&#34;</span> <span style=color:#f92672>=</span> {
  values_num1 <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>rep_len</span>(<span style=color:#66d9ef>NA</span>, <span style=color:#a6e22e>length</span>(values))
  <span style=color:#a6e22e>for </span>(i in <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#a6e22e>length</span>(values_num1)) {
    <span style=color:#a6e22e>if </span>(values[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Low&#34;</span>) values_num1[i] <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>0</span>
    <span style=color:#a6e22e>if </span>(values[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Middle&#34;</span>) values_num1[i] <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span>
    <span style=color:#a6e22e>if </span>(values[i] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;High&#34;</span>) values_num1[i] <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>2</span>
  }
}, <span style=color:#e6db74>&#34;vectorized&#34;</span> <span style=color:#f92672>=</span> {
  values_num2 <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>as.numeric</span>(values <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Middle&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>as.numeric</span>(values <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;High&#34;</span>)
})

compare
</code></pre></div><pre tabindex=0><code>## Unit: microseconds
##        expr      min       lq      mean   median       uq      max
##        loop 3991.204 4023.503 4198.8841 4053.097 4149.492 5594.456
##  vectorized  105.098  106.666  110.4647  111.180  113.387  131.265
##  neval
##    100
##    100
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=compareTwoImpl-1.png alt="plot of chunk compareTwoImpl"></p>
<h4 id=r-is-a-dynamic-language>R is a dynamic language</h4>
<p>Unlike C/C++, objects in R can change quite a lot during a computation: data frames can become matrices, we can flatten lists and create atomic vectors, the class of an object can be modified multiple times, etc. This flexibility, however, usually comes with a computational cost. For example, most functions you can find in packages will perform &ldquo;input checking&rdquo; to control the behaviour. Understanding R coercion rules can sometimes lead to faster (and more predictable) code.</p>
<p>For example, the function <code>sapply</code> will apply a function to each element of a list and try to simplify the input to an array. However, if simplification is not possible, it will output a list <strong>without any warning</strong>. For this reason, it is preferable to use <code>vapply</code>, which takes one more argument: an example of desired output.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>foo <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>list</span>(<span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>), <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>))

<span style=color:#a6e22e>sapply</span>(foo, Filter, f <span style=color:#f92672>=</span> <span style=color:#a6e22e>function</span>(t) t <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)
</code></pre></div><pre tabindex=0><code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1 1
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>vapply</span>(foo, Filter, f <span style=color:#f92672>=</span> <span style=color:#a6e22e>function</span>(t) t <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1L</span>)
</code></pre></div><pre tabindex=0><code>## Error in vapply(foo, Filter, f = function(t) t == 1, 1L): values must be type 'integer',
##  but FUN(X[[1]]) result is type 'double'
</code></pre><p>Because we are telling <code>vapply</code> what type of output we expect, this can actually lead to faster code:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>fits <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>lapply</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>100</span>, <span style=color:#a6e22e>function</span>(t) {
  <span style=color:#a6e22e>lm</span>(<span style=color:#a6e22e>rnorm</span>(<span style=color:#ae81ff>100</span>) <span style=color:#f92672>~</span> <span style=color:#a6e22e>rnorm</span>(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>2</span>))
})

compare <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>microbenchmark</span>(<span style=color:#e6db74>&#34;sapply&#34;</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>sapply</span>(fits, coef)
}, <span style=color:#e6db74>&#34;vapply&#34;</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>vapply</span>(fits, coef, <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>))
})

compare
</code></pre></div><pre tabindex=0><code>## Unit: microseconds
##    expr     min       lq     mean  median       uq      max neval
##  sapply 596.619 621.1735 650.6462 638.453 682.5425  919.996   100
##  vapply 516.375 540.4710 583.9992 562.221 594.6660 2332.687   100
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=unnamed-chunk-9-1.png alt="plot of chunk unnamed-chunk-9"></p>
<p>For this example, the efficiency gain is minimal. As another example, imagine you want to make sure that when you select columns of a matrix, you still get a matrix and not an atomic vector (when subsetting, R will by default coerce a matrix with one row or one column to a vector). You can coerce the result to a matrix, or use the (little known) <code>drop</code> argument of the function <code>[</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>mat <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>matrix</span>(<span style=color:#a6e22e>rnorm</span>(<span style=color:#ae81ff>20</span><span style=color:#f92672>*</span><span style=color:#ae81ff>100</span>), nrow<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>, ncol<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>)

compare <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>microbenchmark</span>(<span style=color:#e6db74>&#34;coerce&#34;</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>as.matrix</span>(mat[,<span style=color:#ae81ff>1</span>])
}, <span style=color:#e6db74>&#34;drop&#34;</span> <span style=color:#f92672>=</span> {
  mat[,<span style=color:#ae81ff>1</span>,drop<span style=color:#f92672>=</span><span style=color:#66d9ef>FALSE</span>]
})

compare
</code></pre></div><pre tabindex=0><code>## Unit: microseconds
##    expr    min     lq     mean  median     uq    max neval
##  coerce 12.001 12.314 14.09449 12.5650 12.913 54.198   100
##    drop  2.424  2.751  3.08146  3.0085  3.239 11.422   100
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=unnamed-chunk-10-1.png alt="plot of chunk unnamed-chunk-10"></p>
<p>There is an 8-fold difference between the two methods. We would still need to check if the two methods give the same result:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>identical</span>(<span style=color:#a6e22e>as.matrix</span>(mat[,<span style=color:#ae81ff>1</span>]), mat[,<span style=color:#ae81ff>1</span>,drop<span style=color:#f92672>=</span><span style=color:#66d9ef>FALSE</span>])
</code></pre></div><pre tabindex=0><code>## [1] TRUE
</code></pre><h4 id=memory-allocation>Memory allocation</h4>
<p>Somewhat related to the dynamism of R is the fact that memory can be frequently re-allocated during your computations, and this can lead to decrease in performance. For example, it is better to pre-allocate a vector for the results of a computation than use a <code>for</code> loop to continually grow the results:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>compare <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>microbenchmark</span>(<span style=color:#e6db74>&#34;preallocate&#34;</span> <span style=color:#f92672>=</span> {
  results <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>rep</span>(<span style=color:#66d9ef>NA</span>, <span style=color:#ae81ff>10000</span>)
  <span style=color:#a6e22e>for</span>(i in <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#a6e22e>length</span>(results)) {
    results[i] <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>runif</span>(<span style=color:#ae81ff>1</span>)
  }
}, <span style=color:#e6db74>&#34;growing&#34;</span> <span style=color:#f92672>=</span> {
  results <span style=color:#f92672>=</span> <span style=color:#66d9ef>NULL</span>
  <span style=color:#a6e22e>for</span>(i in <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>10000</span>) {
    results <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>(results, <span style=color:#a6e22e>runif</span>(<span style=color:#ae81ff>1</span>))
  }
})

compare
</code></pre></div><pre tabindex=0><code>## Unit: milliseconds
##         expr       min        lq      mean    median        uq
##  preallocate  53.61208  54.54148  57.95674  55.47454  55.86745
##      growing 340.49902 344.88623 375.49227 391.02795 395.07053
##       max neval
##  111.5387   100
##  412.6016   100
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=unnamed-chunk-12-1.png alt="plot of chunk unnamed-chunk-12"></p>
<p>Of course, this is a silly example, because we could simply use the vectorised form <code>runif(10000)</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>compare <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>microbenchmark</span>(<span style=color:#e6db74>&#34;preallocate&#34;</span> <span style=color:#f92672>=</span> {
  results <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>rep</span>(<span style=color:#66d9ef>NA</span>, <span style=color:#ae81ff>10000</span>)
  <span style=color:#a6e22e>for</span>(i in <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#a6e22e>length</span>(results)) {
    results[i] <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>runif</span>(<span style=color:#ae81ff>1</span>)
  }
}, <span style=color:#e6db74>&#34;growing&#34;</span> <span style=color:#f92672>=</span> {
  results <span style=color:#f92672>=</span> <span style=color:#66d9ef>NULL</span>
  <span style=color:#a6e22e>for</span>(i in <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>10000</span>) {
    results <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>(results, <span style=color:#a6e22e>runif</span>(<span style=color:#ae81ff>1</span>))
  }
}, <span style=color:#e6db74>&#34;vectorize&#34;</span> <span style=color:#f92672>=</span> {
  results <span style=color:#f92672>=</span> <span style=color:#a6e22e>runif</span>(<span style=color:#ae81ff>10000</span>)
  })

<span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=unnamed-chunk-13-1.png alt="plot of chunk unnamed-chunk-13"></p>
<p>For other examples of what to do and what not to do, I recommend the book <a href=http://www.burns-stat.com/pages/Tutor/R_inferno.pdf>R Inferno</a>. For example, memory allocation is discussed in Circle 2 and vectorisation, in Circle 3.</p>
<h3 id=profiling-your-code>Profiling your code</h3>
<p>We will now assume that our code is correct (i.e. debugged) and that we are looking for bottlenecks. This process is called <em>profiling</em>. We will see three slightly different ways of profiling your R code: the method available in base R through the functions <code>Rprof</code> and <code>summaryRprof</code>, the <code>proftable</code> function from <a href=http://www.noamross.net/blog/2013/5/2/improved-r-profiling-summaries.html>Noam Ross</a>, and the <code>proftools</code> <a href=https://cran.r-project.org/web/packages/proftools/index.html>package</a> by Luke Tierney.</p>
<p>The main concept behind code profiling in R is that, while the code is running, we randomly sample time points at which we check which functions are being called. This is done by the function <code>Rprof</code>, which records this information in a text file. We can then call the function <code>summaryRprof</code>, which gives a summary of this information. Let&rsquo;s look at an example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#75715e># This example is taken from the MASS package</span>
<span style=color:#a6e22e>library</span>(MASS)

Iris <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>data.frame</span>(<span style=color:#a6e22e>rbind</span>(iris3[,,<span style=color:#ae81ff>1</span>], iris3[,,<span style=color:#ae81ff>2</span>], iris3[,,<span style=color:#ae81ff>3</span>]),
Sp <span style=color:#f92672>=</span> <span style=color:#a6e22e>rep</span>(<span style=color:#a6e22e>c</span>(<span style=color:#e6db74>&#34;s&#34;</span>,<span style=color:#e6db74>&#34;c&#34;</span>,<span style=color:#e6db74>&#34;v&#34;</span>), <span style=color:#a6e22e>rep</span>(<span style=color:#ae81ff>50</span>,<span style=color:#ae81ff>3</span>)))
train <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>sample</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>150</span>, <span style=color:#ae81ff>75</span>)
<span style=color:#a6e22e>table</span>(Iris<span style=color:#f92672>$</span>Sp[train])
</code></pre></div><pre tabindex=0><code>## 
##  c  s  v 
## 25 25 25
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>Rprof</span>(tmp <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>tempfile</span>())

res <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>replicate</span>(<span style=color:#ae81ff>100</span>, expr <span style=color:#f92672>=</span> {
  z <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>lda</span>(Sp <span style=color:#f92672>~</span> ., Iris, prior <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>, subset <span style=color:#f92672>=</span> train)
  <span style=color:#a6e22e>predict</span>(z, Iris[<span style=color:#f92672>-</span>train, ])<span style=color:#f92672>$</span>class
  z1 <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>update</span>(z, . <span style=color:#f92672>~</span> . <span style=color:#f92672>-</span> Petal.W.)
}, simplify <span style=color:#f92672>=</span> <span style=color:#66d9ef>FALSE</span>)

<span style=color:#a6e22e>Rprof</span>()

<span style=color:#a6e22e>summaryRprof</span>(tmp)
</code></pre></div><pre tabindex=0><code>## $by.self
##                        self.time self.pct total.time total.pct
## &quot;&lt;Anonymous&gt;&quot;               0.04     4.17       0.96    100.00
## &quot;model.frame.default&quot;       0.04     4.17       0.30     31.25
## &quot;[.data.frame&quot;              0.04     4.17       0.12     12.50
## &quot;na.omit.data.frame&quot;        0.04     4.17       0.12     12.50
## &quot;%in%&quot;                      0.04     4.17       0.06      6.25
## &quot;La.svd&quot;                    0.04     4.17       0.06      6.25
## &quot;unique&quot;                    0.04     4.17       0.06      6.25
## &quot;aperm&quot;                     0.04     4.17       0.04      4.17
## &quot;apply&quot;                     0.04     4.17       0.04      4.17
## &quot;levels&quot;                    0.04     4.17       0.04      4.17
## &quot;lapply&quot;                    0.02     2.08       0.96    100.00
## &quot;lda.formula&quot;               0.02     2.08       0.76     79.17
## &quot;update&quot;                    0.02     2.08       0.32     33.33
## &quot;.External2&quot;                0.02     2.08       0.20     20.83
## &quot;model.matrix.default&quot;      0.02     2.08       0.12     12.50
## &quot;[&quot;                         0.02     2.08       0.10     10.42
## &quot;paste&quot;                     0.02     2.08       0.10     10.42
## &quot;.deparseOpts&quot;              0.02     2.08       0.06      6.25
## &quot;sweep&quot;                     0.02     2.08       0.06      6.25
## &quot;[.factor&quot;                  0.02     2.08       0.04      4.17
## &quot;match.call&quot;                0.02     2.08       0.04      4.17
## &quot;rep.factor&quot;                0.02     2.08       0.04      4.17
## &quot;as.integer&quot;                0.02     2.08       0.02      2.08
## &quot;as.matrix&quot;                 0.02     2.08       0.02      2.08
## &quot;c&quot;                         0.02     2.08       0.02      2.08
## &quot;colnames&quot;                  0.02     2.08       0.02      2.08
## &quot;colSums&quot;                   0.02     2.08       0.02      2.08
## &quot;delete.response&quot;           0.02     2.08       0.02      2.08
## &quot;is.finite&quot;                 0.02     2.08       0.02      2.08
## &quot;is.ordered&quot;                0.02     2.08       0.02      2.08
## &quot;lengths&quot;                   0.02     2.08       0.02      2.08
## &quot;match.fun&quot;                 0.02     2.08       0.02      2.08
## &quot;mean.default&quot;              0.02     2.08       0.02      2.08
## &quot;min&quot;                       0.02     2.08       0.02      2.08
## &quot;mode&quot;                      0.02     2.08       0.02      2.08
## &quot;NextMethod&quot;                0.02     2.08       0.02      2.08
## &quot;parent.frame&quot;              0.02     2.08       0.02      2.08
## &quot;sys.function&quot;              0.02     2.08       0.02      2.08
## 
## $by.total
##                        total.time total.pct self.time self.pct
## &quot;&lt;Anonymous&gt;&quot;                0.96    100.00      0.04     4.17
## &quot;lapply&quot;                     0.96    100.00      0.02     2.08
## &quot;block_exec&quot;                 0.96    100.00      0.00     0.00
## &quot;call_block&quot;                 0.96    100.00      0.00     0.00
## &quot;doTryCatch&quot;                 0.96    100.00      0.00     0.00
## &quot;eval&quot;                       0.96    100.00      0.00     0.00
## &quot;eval.parent&quot;                0.96    100.00      0.00     0.00
## &quot;evaluate_call&quot;              0.96    100.00      0.00     0.00
## &quot;FUN&quot;                        0.96    100.00      0.00     0.00
## &quot;handle&quot;                     0.96    100.00      0.00     0.00
## &quot;in_dir&quot;                     0.96    100.00      0.00     0.00
## &quot;local&quot;                      0.96    100.00      0.00     0.00
## &quot;process_file&quot;               0.96    100.00      0.00     0.00
## &quot;process_group&quot;              0.96    100.00      0.00     0.00
## &quot;process_group.block&quot;        0.96    100.00      0.00     0.00
## &quot;replicate&quot;                  0.96    100.00      0.00     0.00
## &quot;sapply&quot;                     0.96    100.00      0.00     0.00
## &quot;try&quot;                        0.96    100.00      0.00     0.00
## &quot;tryCatch&quot;                   0.96    100.00      0.00     0.00
## &quot;tryCatchList&quot;               0.96    100.00      0.00     0.00
## &quot;tryCatchOne&quot;                0.96    100.00      0.00     0.00
## &quot;withCallingHandlers&quot;        0.96    100.00      0.00     0.00
## &quot;withVisible&quot;                0.96    100.00      0.00     0.00
## &quot;lda.formula&quot;                0.76     79.17      0.02     2.08
## &quot;lda&quot;                        0.76     79.17      0.00     0.00
## &quot;lda.default&quot;                0.34     35.42      0.00     0.00
## &quot;update&quot;                     0.32     33.33      0.02     2.08
## &quot;model.frame.default&quot;        0.30     31.25      0.04     4.17
## &quot;update.default&quot;             0.30     31.25      0.00     0.00
## &quot;.External2&quot;                 0.20     20.83      0.02     2.08
## &quot;predict&quot;                    0.18     18.75      0.00     0.00
## &quot;predict.lda&quot;                0.18     18.75      0.00     0.00
## &quot;[.data.frame&quot;               0.12     12.50      0.04     4.17
## &quot;na.omit.data.frame&quot;         0.12     12.50      0.04     4.17
## &quot;model.matrix.default&quot;       0.12     12.50      0.02     2.08
## &quot;model.matrix&quot;               0.12     12.50      0.00     0.00
## &quot;na.omit&quot;                    0.12     12.50      0.00     0.00
## &quot;[&quot;                          0.10     10.42      0.02     2.08
## &quot;paste&quot;                      0.10     10.42      0.02     2.08
## &quot;match&quot;                      0.10     10.42      0.00     0.00
## &quot;tapply&quot;                     0.10     10.42      0.00     0.00
## &quot;deparse&quot;                    0.08      8.33      0.00     0.00
## &quot;diag&quot;                       0.08      8.33      0.00     0.00
## &quot;svd&quot;                        0.08      8.33      0.00     0.00
## &quot;%in%&quot;                       0.06      6.25      0.04     4.17
## &quot;La.svd&quot;                     0.06      6.25      0.04     4.17
## &quot;unique&quot;                     0.06      6.25      0.04     4.17
## &quot;.deparseOpts&quot;               0.06      6.25      0.02     2.08
## &quot;sweep&quot;                      0.06      6.25      0.02     2.08
## &quot;scale&quot;                      0.06      6.25      0.00     0.00
## &quot;scale.default&quot;              0.06      6.25      0.00     0.00
## &quot;simplify2array&quot;             0.06      6.25      0.00     0.00
## &quot;aperm&quot;                      0.04      4.17      0.04     4.17
## &quot;apply&quot;                      0.04      4.17      0.04     4.17
## &quot;levels&quot;                     0.04      4.17      0.04     4.17
## &quot;[.factor&quot;                   0.04      4.17      0.02     2.08
## &quot;match.call&quot;                 0.04      4.17      0.02     2.08
## &quot;rep.factor&quot;                 0.04      4.17      0.02     2.08
## &quot;[[&quot;                         0.04      4.17      0.00     0.00
## &quot;[[.data.frame&quot;              0.04      4.17      0.00     0.00
## &quot;rep&quot;                        0.04      4.17      0.00     0.00
## &quot;as.integer&quot;                 0.02      2.08      0.02     2.08
## &quot;as.matrix&quot;                  0.02      2.08      0.02     2.08
## &quot;c&quot;                          0.02      2.08      0.02     2.08
## &quot;colnames&quot;                   0.02      2.08      0.02     2.08
## &quot;colSums&quot;                    0.02      2.08      0.02     2.08
## &quot;delete.response&quot;            0.02      2.08      0.02     2.08
## &quot;is.finite&quot;                  0.02      2.08      0.02     2.08
## &quot;is.ordered&quot;                 0.02      2.08      0.02     2.08
## &quot;lengths&quot;                    0.02      2.08      0.02     2.08
## &quot;match.fun&quot;                  0.02      2.08      0.02     2.08
## &quot;mean.default&quot;               0.02      2.08      0.02     2.08
## &quot;min&quot;                        0.02      2.08      0.02     2.08
## &quot;mode&quot;                       0.02      2.08      0.02     2.08
## &quot;NextMethod&quot;                 0.02      2.08      0.02     2.08
## &quot;parent.frame&quot;               0.02      2.08      0.02     2.08
## &quot;sys.function&quot;               0.02      2.08      0.02     2.08
## &quot;as.vector&quot;                  0.02      2.08      0.00     0.00
## &quot;formals&quot;                    0.02      2.08      0.00     0.00
## &quot;.getXlevels&quot;                0.02      2.08      0.00     0.00
## &quot;match.arg&quot;                  0.02      2.08      0.00     0.00
## &quot;model.frame&quot;                0.02      2.08      0.00     0.00
## &quot;nlevels&quot;                    0.02      2.08      0.00     0.00
## &quot;stopifnot&quot;                  0.02      2.08      0.00     0.00
## &quot;structure&quot;                  0.02      2.08      0.00     0.00
## &quot;table&quot;                      0.02      2.08      0.00     0.00
## &quot;vapply&quot;                     0.02      2.08      0.00     0.00
## &quot;var&quot;                        0.02      2.08      0.00     0.00
## 
## $sample.interval
## [1] 0.02
## 
## $sampling.time
## [1] 0.96
</code></pre><p>There are two main components to this summary:</p>
<ol>
<li>
<p><code>by.self</code>, which represents the time spent in the function alone.</p>
</li>
<li>
<p><code>by.total</code>, which represents the time spent in the function, and all other functions it called.</p>
</li>
</ol>
<p>Note that we have wrapped the code in a call to <code>replicate</code>, as suggested by the <a href=http://www.hep.by/gnu/r-patched/r-exts/R-exts_71.html#SEC71>documentation</a>, since its running time is very small. This is actually part of the profiling, and therefore makes it even more difficult to understand the output. This is why I recommand using Noam Ross&rsquo;s <code>proftable</code> function. It takes the text file created by <code>Rprof</code>, but summarizes it differently:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>proftable</span>(tmp)
</code></pre></div><pre tabindex=0><code>##  PctTime
##  4.17   
##  4.17   
##  4.17   
##  4.17   
##  2.08   
##  2.08   
##  2.08   
##  2.08   
##  2.08   
##  2.08   
##  Call                                                                                                    
##  lda &gt; lda.formula &gt; model.frame.default &gt; .External2 &gt; na.omit &gt; na.omit.data.frame                     
##  predict &gt; predict.lda &gt; apply                                                                           
##  predict &gt; predict.lda &gt; scale &gt; scale.default &gt; sweep &gt; aperm                                           
##  update &gt; update.default &gt; lda &gt; lda.formula &gt; lda.default &gt; svd &gt; La.svd                                
##  lda &gt; lda.formula                                                                                       
##  lda &gt; lda.formula &gt; model.frame.default                                                                 
##  lda &gt; lda.formula &gt; model.frame.default &gt; .External2 &gt; [.data.frame &gt; [                                 
##  lda &gt; lda.formula &gt; model.frame.default &gt; .External2 &gt; [.data.frame &gt; [ &gt; [.factor                      
##  lda &gt; lda.formula &gt; model.frame.default &gt; .External2 &gt; na.omit &gt; na.omit.data.frame &gt; [ &gt; [.data.frame  
##  lda &gt; lda.formula &gt; model.frame.default &gt; .External2 &gt; na.omit &gt; na.omit.data.frame &gt; [[ &gt; [[.data.frame
## 
## Parent Call: local &gt; eval.parent &gt; eval &gt; eval &gt; eval &gt; eval &gt; &lt;Anonymous&gt; &gt; process_file &gt; withCallingHandlers &gt; process_group &gt; process_group.block &gt; call_block &gt; block_exec &gt; in_dir &gt; &lt;Anonymous&gt; &gt; evaluate_call &gt; handle &gt; try &gt; tryCatch &gt; tryCatchList &gt; tryCatchOne &gt; doTryCatch &gt; withCallingHandlers &gt; withVisible &gt; eval &gt; eval &gt; replicate &gt; sapply &gt; lapply &gt; FUN &gt; ...
## 
## Total Time: 0.96 seconds
## Percent of run time represented: 29.2 %
</code></pre><p>First of all, we can see that the call to <code>replicate</code> is now relegated to the end and removed from the general summary. Second, we see the chain of calls, which helps us understand what some functions we didn&rsquo;t call directly (e.g. <code>.getXlevels</code> or <code>model.frame.default</code>) actually do. Finally, it only shows the first few lines, ordered by their percentage of the whole running time, and therefore it is easier to read. For all these reasons, I recommend the use of <code>proftable</code> over <code>summaryRprof</code>.</p>
<p>There exist also graphical ways of representing the call stack. One example is the <code>proftools</code> package. Note that it requires the <code>graph</code> and <code>Rgraphviz</code> packages, which are available on <a href=http://bioconductor.org/>Bioconductor</a>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>library</span>(proftools)
<span style=color:#a6e22e>library</span>(graphics)

<span style=color:#a6e22e>Rprof</span>(tmp <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>tempfile</span>())
<span style=color:#75715e># Clustering example</span>
test.data <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>function</span>(dim, num, seed<span style=color:#f92672>=</span><span style=color:#ae81ff>12345</span>) { 
   <span style=color:#a6e22e>set.seed</span>(seed) 
   <span style=color:#a6e22e>matrix</span>(<span style=color:#a6e22e>rnorm</span>(dim <span style=color:#f92672>*</span> num), nrow<span style=color:#f92672>=</span>num) 
} 
m <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>test.data</span>(<span style=color:#ae81ff>120</span>, <span style=color:#ae81ff>4500</span>) 
 
<span style=color:#a6e22e>hclust</span>(<span style=color:#a6e22e>dist</span>(m))
</code></pre></div><pre tabindex=0><code>## 
## Call:
## hclust(d = dist(m))
## 
## Cluster method   : complete 
## Distance         : euclidean 
## Number of objects: 4500
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>Rprof</span>()

<span style=color:#a6e22e>plotProfileCallGraph</span>(<span style=color:#a6e22e>readProfileData</span>(tmp),
                     score <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;total&#34;</span>)
</code></pre></div><p><img src=proftools-1.png alt="plot of chunk proftools"></p>
<p>The colours are used to represent the amount of time used by each function. As we can see, the <code>dist</code> function is the real bottleneck in this example, and therefore improving the running time would necessitate a faster algorithm for computing the Euclidean distance.</p>
<p>We can see all these functions being used in a real-life <a href=/optimisation-test-case>example</a>, where I tried to optimise the main component of the function which computes the PCEV in order to speed up my simulations. Follow the link to see the different steps I took.</p>
<h3 id=other-things-to-keep-in-mind>Other things to keep in mind</h3>
<p>Profiling the code is the best way to identify bottleneck, but it doesn&rsquo;t directly tell us how to optimise our code. Below, I give three general ideas to keep in mind.</p>
<h4 id=a-faster-implementation>A faster implementation</h4>
<p>The greatest strength of R is its massive package ecosystem. Often, we don&rsquo;t need to write from scratch the code for a new method appearing in a paper because its authors have already published a package. Moreover, different packages may have different implementations of a same (or similar) method. This means that, sometimes, a faster implementation (or even a more efficient algorithm) can be used simply by changing the function call. One example of this is the <code>slanczos</code> function in the <code>mgcv</code> package: it computes the eigenvectors of a square matrix using a different algorithm than the one used by <code>eigen</code>. One advantage of this particular algorithm is its <em>iterative</em> nature: eigenvectors are computed one at a time, and therefore if we only need the eigenvector corresponding to the largest eigenvalue, it is possibly faster to use <code>slanczos</code> than <code>eigen</code>; from experience, I would say that this depends a lot on the size of the matrix and how many eigenvectors you need.</p>
<p>The next example is related to our discussion of design choices for R. R implements what is called <em>modify-on-copy</em>, which means that when we modify an object a (possibly partial) copy is made. For example, when we write</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>x <span style=color:#f92672>&lt;-</span> x[,<span style=color:#a6e22e>c</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>4</span>)]
</code></pre></div><p>the result of subsetting <code>x</code> on its columns is stored in a temporary variable, which is then assigned <code>x</code> (and in fact, this is what allows us to use <code>x</code> on both sides of the assignment operator). This allows for clearer code, but it actually slows down the execution and can lead to quite a lot of memory being used (this is why it is usually suggested to fill your memory only up to one third of its capacity, leaving space for all these copies).</p>
<p>Enter the <a href=https://cran.r-project.org/web/packages/data.table/index.html>package</a> <code>data.table</code>. For large datasets, it can be significantly faster (i.e. several orders of magnitude) than using a plain data frame. Its speed comes from a new implementation of the usual data frame routines (e.g. rbind, subset, etc.) using a pass-by-reference syntax; in other words, <strong>no copy of the data is made during modification</strong> (although this behaviour <a href=http://stackoverflow.com/questions/10225098/understanding-exactly-when-a-data-table-is-a-reference-to-vs-a-copy-of-another>can actually be broken if not used properly</a>).</p>
<h4 id=byte-code-compilation>Byte-code compilation</h4>
<p>Recall from above that R is an interpreted language. The code we run has to be decomposed in small parts (called <em>token</em>) which are then mapped to pre-compiled code. One way to speed up your code is therefore to do this mapping once and for all for functions (or expressions) that are used quite often; this can be done using the <code>compiler</code> package (which is now part of the standard packages you get by default).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>library</span>(compiler)

<span style=color:#75715e># Original implementation of lapply</span>
old_lapply <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>function</span>(X, FUN, <span style=color:#66d9ef>...</span>) {
   FUN <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>match.fun</span>(FUN)
   <span style=color:#a6e22e>if </span>(<span style=color:#f92672>!</span><span style=color:#a6e22e>is.list</span>(X))
    X <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>as.list</span>(X)
   rval <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>vector</span>(<span style=color:#e6db74>&#34;list&#34;</span>, <span style=color:#a6e22e>length</span>(X))
   <span style=color:#a6e22e>for</span>(i in <span style=color:#a6e22e>seq</span>(along <span style=color:#f92672>=</span> X))
    rval[i] <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>list</span>(<span style=color:#a6e22e>FUN</span>(X[[i]], <span style=color:#66d9ef>...</span>))
   <span style=color:#a6e22e>names</span>(rval) <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>names</span>(X)          
   <span style=color:#a6e22e>return</span>(rval)
}

old_lapply_comp <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>cmpfun</span>(old_lapply)

data <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>lapply</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1000</span>, <span style=color:#a6e22e>function</span>(i) <span style=color:#a6e22e>rnorm</span>(<span style=color:#ae81ff>100</span>))

compare <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>microbenchmark</span>(<span style=color:#e6db74>&#34;original&#34;</span><span style=color:#f92672>=</span><span style=color:#a6e22e>old_lapply</span>(data, mean),
                          <span style=color:#e6db74>&#34;compiled&#34;</span><span style=color:#f92672>=</span><span style=color:#a6e22e>old_lapply_comp</span>(data, mean),
                          <span style=color:#e6db74>&#34;new&#34;</span><span style=color:#f92672>=</span><span style=color:#a6e22e>lapply</span>(data,mean), times<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span>)
compare
</code></pre></div><pre tabindex=0><code>## Unit: milliseconds
##      expr      min       lq     mean   median       uq      max neval
##  original 8.540425 8.810987 9.203373 8.906748 8.999030 95.57505  1000
##  compiled 6.803040 7.028638 7.291496 7.102944 7.204534 15.12300  1000
##       new 6.009491 6.229223 6.523165 6.306225 6.393313 90.89608  1000
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=color:#a6e22e>autoplot</span>(compare)
</code></pre></div><p><img src=comp-1.png alt="plot of chunk comp"></p>
<p>As we can see, byte-code compilation actually improves speed, even though the new implementation is even faster. Similarly, expressions can be compiled using the function <code>compile</code>, and the result can be evaluated using <code>eval</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r>expr <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>compile</span>(<span style=color:#a6e22e>rev</span>(<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>100</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>100</span>)
<span style=color:#a6e22e>eval</span>(expr)
</code></pre></div><p>To see how the <code>compiler</code> package can be used to turn the usual interpreter into a &ldquo;just-in-time&rdquo; compiler, see the <a href=http://www.r-statistics.com/2012/04/speed-up-your-r-code-using-a-just-in-time-jit-compiler/>following blog post</a>.</p>
<h3 id=concluding-remarks>Concluding remarks</h3>
<p>In this tutorial, we first discussed why you would want to optimise your code, and how to keep in mind some of the key features of R so that the code you write in the first place isn&rsquo;t too bad. We then showed how to benchmark pieces of code, and how to use some of the many profiling resources out there.</p>
<p>This is not the end of the discussion. Two main points I didn&rsquo;t discuss are how to incorporate low-level languages (e.g. C, C++, Fortran) in your code, and how to take advantage of multiple cores to do parts of the computations in parallel. These two points are already well covered in some other places, like <a href=http://adv-r.had.co.nz/Rcpp.html>here</a> and <a href=http://blog.yhathq.com/posts/running-r-in-parallel.html>here</a>.</p>
<p>Finally, two more options to consider (but a lot more drastic!) are to either <a href=http://edustatistics.org/nathanvan/2013/07/09/for-faster-r-use-openblas-instead-better-than-atlas-trivial-to-switch-to-on-ubuntu/>link your version of R to a different, more efficient BLAS (Basic Linear Algebra System)</a>, or even to go for a faster R implementation (e.g. <a href=http://www.pqr-project.org/>pretty quick R</a> or <a href=http://www.renjin.org/>Renjin</a>). However, I haven&rsquo;t tried either option, and therefore I cannot comment on them.</p>
<p>In conclusion, another quote from Donald Knuth (pointed out by Vince Forgetta):</p>
<blockquote>
<p>If you optimize everything, you will always be unhappy. (Donald Knuth)</p>
</blockquote>
<p><strong>Update</strong> (2015-10-15): I&rsquo;ve actually switched to the ATLAS system a few weeks ago, and the improvements I got are similar to the results discussed in the link above. For Ubuntu users, I recommend to make the switch, since there doesn&rsquo;t seem to be any downside!</p>
</div>
</article>
</main>
<footer class=footer>
<ul class=footer-links>
<li>
<a href=/blog/index.xml type=application/rss+xml target=_blank>RSS feed</a>
</li>
<li>
<a href=https://gohugo.io/ class=footer-links-kudos>Made with <img src=/blog/images/hugo-logo.png alt="Img link to Hugo website" width=22 height=22></a>
</li>
</ul>
</footer>
</div>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js></script>
<script>hljs.configure({languages:[]}),hljs.initHighlightingOnLoad()</script>
<script src=/blog/js/math-code.js></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>